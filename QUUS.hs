module QUUS where

import System.Random

data RegEx = Lit Char
           | Any
           | Seq RegEx RegEx
           | Alt RegEx RegEx
           | Opt RegEx
           | Rep RegEx

instance Show RegEx where
  show (Lit c) = [c]
  show Any = "."
  show (Seq e e') = "(" ++ show e ++ show e' ++ ")"
  show (Alt e e') = "(" ++ show e ++ "|" ++ show e' ++ ")"
  show (Opt e) = show e ++ "?"
  show (Rep e) = show e ++ "+"


generate_string :: RegEx -> IO String
generate_string (Lit c) = return [c]
generate_string Any =
  do i <- randomRIO (0,25) :: IO Int
     return [['a'..'z'] !! i]
generate_string (Seq e e') =
  do s <- generate_string e
     s' <- generate_string e'
     return (s ++ s')
generate_string (Alt e e') =
  do i <- randomRIO (0,1) :: IO Int
     if 0 == i
        then generate_string e
        else generate_string e'
generate_string (Opt e) =
  do i <- randomRIO (0,1) :: IO Int
     if 0 == i
        then generate_string e
        else return ""
generate_string (Rep e) =
  do i <- randomRIO (1,10) :: IO Int
     ss <- sequence (replicate i (generate_string e))
     return (concat ss)


generate_regex :: Int -> IO RegEx
generate_regex 0 =
  do i <- randomRIO (0,1) :: IO Int
     if i == 0
        then return Any
        else do j <- randomRIO (0,25) :: IO Int
                return (Lit (['a'..'z'] !! j))
generate_regex n =
  do i <- randomRIO (0,5) :: IO Int
     case i of
       0 -> return Any
       1 -> do j <- randomRIO (0,25) :: IO Int
               return (Lit (['a'..'z'] !! j))
       2 -> do e <- generate_regex (n - 1)
               e' <- generate_regex (n - 1)
               return (Seq e e')
       3 -> do e <- generate_regex (n - 1)
               e' <- generate_regex (n - 1)
               return (Alt e e')
       4 -> do e <- generate_regex (n - 1)
               return (Opt e)
       5 -> do e <- generate_regex (n - 1)
               return (Rep e)



quus :: IO ()
quus =
  do putStr preamble
     putStr "What maximum difficulty would you like to play on? 1-10 "
     is <- getLine
     putStr "\n"
     let difficulty = read is :: Int
     regex_goal <- generate_regex difficulty
     regex_distractor <- generate_regex difficulty
     putStr "Here are 10 strings randomly generated by the regular expression:\n\n"
     ss <- sequence (replicate 10 (generate_string regex_goal))
     flip mapM_ (zip [0..] ss) $ \(i,s) -> putStr (show i ++ ": " ++ s ++ "\n\n")
     
     loop regex_goal regex_distractor 10 0
  
  where
    loop regex_goal regex_distractor remaining score =
      if 0 == remaining
         then do putStr ("Your final score is " ++ show score ++ "/10!\n")
                 putStr ("The goal regular expression was /" ++ show regex_goal ++ "/\n")
                 putStr ("The distractor regular expression was /" ++ show regex_distractor ++ "/\n")
                 putStr "Fuuuuuuck Perl!\n\n\n"
                 putStr "References\n"
                 putStr "----------\n\n"
                 putStr "Kripke, Saul. (1982). Wittgenstein on Rules and Private Languages. Harvard\nUniversity Press. ISBN 0-674-95401-7.\n\n\n";
         else do choice <- randomRIO (0,1) :: IO Int
                 gen <- if choice == 0
                           then generate_string regex_distractor
                           else generate_string regex_goal
                 putStr ("How about '" ++ gen ++ "'? ")
                 response <- getLine
                 handleResponse choice gen response
      where
        handleResponse choice gen "y" =
          if 0 == choice
             then do putStr "Sorry, that's wrong. :(\n\n"
                     loop regex_goal regex_distractor (remaining - 1) score
             else do putStr "Hooray! You got it! :)\n\n"
                     loop regex_goal regex_distractor (remaining - 1) (score + 1)
        handleResponse choice gen "n" =
          if 1 == choice
             then do putStr "Sorry, that's wrong. :(\n\n"
                     loop regex_goal regex_distractor (remaining - 1) score
             else do putStr "Hooray! You got it! :)\n\n"
                     loop regex_goal regex_distractor (remaining - 1) (score + 1)
        handleResponse choice gen _ =
          do putStr "That's not a valid response! "
             response <- getLine
             handleResponse choice gen response
    preamble =
      "Welcome to ...\n\
      \\n\
      \                                             !!!\n\
      \                                            !!!!!\n\
      \   QQQ     UUU   UUU  UUU   UUU     SSSS    !!!!!\n\
      \ QQQQQQQ   UUU   UUU  UUU   UUU   SSSSSSSS  !!!!!\n\
      \QQQ   QQQ  UUU   UUU  UUU   UUU  SSS        !!!!!\n\
      \QQQ   QQQ  UUU   UUU  UUU   UUU   SSSSSS    !!!!!\n\
      \QQQ   QQQ  UUU   UUU  UUU   UUU    SSSSSS    !!!\n\
      \QQQ   QQQ  UUU   UUU  UUU   UUU        SSS  \n\
      \ QQQQQQQ    UUUUUUU    UUUUUUU   SSSSSSSS    !!!\n\
      \   QQQ        UUU        UUU       SSSS      !!!\n\
      \   QQQ\n\
      \    QQQ\n\
      \\n\
      \A Wittgensteinian game about regular expressions!\n\
      \\n\
      \We'll generate a random pair of regular expressions, the Goal and the\n\
      \Distractor, and then show you ten strings that the Goal will match. Then\n\
      \we'll show you some more strings, that are randomly generated by either\n\
      \the Goal or the Distractor. You have to decide whether or not the Goal\n\
      \was responsible for the string.\n\
      \\n\
      \Keep in mind! This is technically impossible! (Kripke, 1982)\n\
      \\n\
      \Good luck!\n\n"
